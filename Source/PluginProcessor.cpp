/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "Reverb.hpp"

AudioProcessor* JUCE_CALLTYPE createPluginFilter();

//==============================================================================
ReverbTestAudioProcessor::ReverbTestAudioProcessor()
    : AudioProcessor(BusesProperties()
                     .withInput("Default Input", juce::AudioChannelSet::stereo())
                     .withOutput("Default Output", juce::AudioChannelSet::stereo())
                     ),
      lastUIWidth (400),
      lastUIHeight (200),
      wetParam (nullptr),
      timeParam (nullptr),
      lpfParam(nullptr),
      cached_reverb_time_(-1),
      cached_er_time_(-1)
{
    lastPosInfo.resetToDefault();

    // This creates our parameters. We'll keep some raw pointers to them in this class,
    // so that we can easily access them later, but the base class will take care of
    // deleting them for us.
    addParameter (wetParam  = new AudioParameterFloat ("dry_wet",  "Dry/Wet", 0.0f, 1.0f, 0.5f));
    addParameter (timeParam = new AudioParameterFloat ("time", "Reverb Time", 0.05f, 6.0f, 0.5f));
    addParameter (lpfParam = new AudioParameterFloat ("lpf", "Air Absorption", 10.0f, 16000.0f, 6000.0f));
    addParameter (erTimeParam = new AudioParameterFloat ("er_time", "ER Time", 0.1f, 200.0f, 20.0f));
    addParameter (erGainParam = new AudioParameterFloat ("er_gain", "ER Gain", 0.0f, 1.0f, 0.7f));
    addParameter (erDampingParam = new AudioParameterFloat ("er_damping", "ER Damping", 10.f, 16000.f, 11000.f));
    addParameter (stereoSpreadParam = new AudioParameterFloat ("stereo_spread", "Stereo Spread", -1.0f, 1.0f, 0.0f));
    addParameter (preDelayParam = new AudioParameterFloat ("pre_delay", "Pre Delay Time(ms)", 0.f, 100.f, 0.0f));
    //! 付けてみたけどあまり効果がないかも
    //! 値を大きくするとフィードバックして発散してしまうので小さい値に抑えている
    addParameter (feedbackGainParam = new AudioParameterFloat ("feedback", "Feedback Gain", 0.f, 0.08f, 0.0f));
}

ReverbTestAudioProcessor::~ReverbTestAudioProcessor()
{
}

//==============================================================================
void ReverbTestAudioProcessor::prepareToPlay (double newSampleRate, int samplesPerBlock)
{
    copy_buffer_.setSize(2, samplesPerBlock);
    reset();
}

void ReverbTestAudioProcessor::releaseResources()
{
}

void ReverbTestAudioProcessor::reset()
{
}

void ReverbTestAudioProcessor::processBlock (AudioBuffer<float>& buffer, MidiBuffer& midiMessages)
{
    jassert (! isUsingDoublePrecision());
    const int numSamples = buffer.getNumSamples();
    copy_buffer_.copyFrom(0, 0, buffer, 0, 0, numSamples);
    copy_buffer_.copyFrom(1, 0, buffer, 1, 0, numSamples);
    buffer.clear();
    
    const float wet_param = *wetParam;
    const float time_param = *timeParam;
    const float er_time = *erTimeParam;
    const float er_damping = *erDampingParam;
    const float lpf_param = *lpfParam;
    const float pre_delay = *preDelayParam;
    const float feedback = *feedbackGainParam;
    
    if(lpf_param != cached_lpf_param_) {
        cached_lpf_param_ = lpf_param;
        SetAirAbsorption(lpf_param);
    }
    if(time_param != cached_reverb_time_) {
        cached_reverb_time_ = time_param;
        SetTimeParam(time_param);
    }
    if(er_time != cached_er_time_) {
        cached_er_time_ = er_time;
        SetErTime(er_time);
    }
    if(er_damping != cached_er_damping_) {
        cached_er_damping_ = er_damping;
        SetErDamping(er_damping);
    }
    if(pre_delay != cached_pre_delay_) {
        cached_pre_delay_ = pre_delay;
        SetPreDelayTime(pre_delay);
    }
    if(feedback != cached_feedback_) {
        cached_feedback_ = feedback;
        SetFeedbackGain(feedback);
    }
    
    SetStereoSpread(*stereoSpreadParam);
    
    ApplyReverb(copy_buffer_, buffer, numSamples, wet_param, *erGainParam);
    
    // Now ask the host for the current time so we can store it to be displayed later...
    updateCurrentTimeInfoFromHost();
}

void ReverbTestAudioProcessor::updateCurrentTimeInfoFromHost()
{
    if (AudioPlayHead* ph = getPlayHead())
    {
        AudioPlayHead::CurrentPositionInfo newTime;

        if (ph->getCurrentPosition (newTime))
        {
            lastPosInfo = newTime;  // Successfully got the current time from the host..
            return;
        }
    }

    // If the host fails to provide the current time, we'll just reset our copy to a default..
    lastPosInfo.resetToDefault();
}

//==============================================================================
AudioProcessorEditor* ReverbTestAudioProcessor::createEditor()
{
    return new ReverbTestAudioProcessorEditor(*this);
}

//==============================================================================
void ReverbTestAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // Here's an example of how you can use XML to make it easy and more robust:

    // Create an outer XML element..
    XmlElement xml ("MYPLUGINSETTINGS");

    // add some attributes to it..
    xml.setAttribute ("uiWidth", lastUIWidth);
    xml.setAttribute ("uiHeight", lastUIHeight);

    // Store the values of all our parameters, using their param ID as the XML attribute
    for (int i = 0; i < getNumParameters(); ++i)
        if (AudioProcessorParameterWithID* p = dynamic_cast<AudioProcessorParameterWithID*> (getParameters().getUnchecked(i)))
            xml.setAttribute (p->paramID, p->getValue());

    // then use this helper function to stuff it into the binary blob and return it..
    copyXmlToBinary (xml, destData);
}

void ReverbTestAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.

    // This getXmlFromBinary() helper function retrieves our XML from the binary blob..
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));

    if (xmlState != nullptr)
    {
        // make sure that it's actually our type of XML object..
        if (xmlState->hasTagName ("MYPLUGINSETTINGS"))
        {
            // ok, now pull out our last window size..
            lastUIWidth  = xmlState->getIntAttribute ("uiWidth", lastUIWidth);
            lastUIHeight = xmlState->getIntAttribute ("uiHeight", lastUIHeight);

            // Now reload our parameters..
            for (int i = 0; i < getNumParameters(); ++i)
                if (AudioProcessorParameterWithID* p = dynamic_cast<AudioProcessorParameterWithID*> (getParameters().getUnchecked(i)))
                    p->setValueNotifyingHost ((float) xmlState->getDoubleAttribute (p->paramID, p->getValue()));
        }
    }
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new ReverbTestAudioProcessor();
}
